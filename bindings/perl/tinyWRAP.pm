# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package tinyWRAP;
use base qw(Exporter);
use base qw(DynaLoader);
package tinyWRAPc;
bootstrap tinyWRAP;
package tinyWRAP;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package tinyWRAP;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package tinyWRAP;


############# Class : tinyWRAP::DDebugCallback ##############

package tinyWRAP::DDebugCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_DDebugCallback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_DDebugCallback($self);
        delete $OWNER{$self};
    }
}

*OnDebugInfo = *tinyWRAPc::DDebugCallback_OnDebugInfo;
*OnDebugWarn = *tinyWRAPc::DDebugCallback_OnDebugWarn;
*OnDebugError = *tinyWRAPc::DDebugCallback_OnDebugError;
*OnDebugFatal = *tinyWRAPc::DDebugCallback_OnDebugFatal;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::AudioResampler ##############

package tinyWRAP::AudioResampler;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_AudioResampler(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_AudioResampler($self);
        delete $OWNER{$self};
    }
}

*isValid = *tinyWRAPc::AudioResampler_isValid;
*getOutputRequiredSizeInShort = *tinyWRAPc::AudioResampler_getOutputRequiredSizeInShort;
*getInputRequiredSizeInShort = *tinyWRAPc::AudioResampler_getInputRequiredSizeInShort;
*process = *tinyWRAPc::AudioResampler_process;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ActionConfig ##############

package tinyWRAP::ActionConfig;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_ActionConfig(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ActionConfig($self);
        delete $OWNER{$self};
    }
}

*addHeader = *tinyWRAPc::ActionConfig_addHeader;
*addPayload = *tinyWRAPc::ActionConfig_addPayload;
*setActiveMedia = *tinyWRAPc::ActionConfig_setActiveMedia;
*setResponseLine = *tinyWRAPc::ActionConfig_setResponseLine;
*setMediaString = *tinyWRAPc::ActionConfig_setMediaString;
*setMediaInt = *tinyWRAPc::ActionConfig_setMediaInt;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::QoS ##############

package tinyWRAP::QoS;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_QoS($self);
        delete $OWNER{$self};
    }
}

*getQavg = *tinyWRAPc::QoS_getQavg;
*getQ1 = *tinyWRAPc::QoS_getQ1;
*getQ2 = *tinyWRAPc::QoS_getQ2;
*getQ3 = *tinyWRAPc::QoS_getQ3;
*getQ4 = *tinyWRAPc::QoS_getQ4;
*getQ5 = *tinyWRAPc::QoS_getQ5;
*getVideoInWidth = *tinyWRAPc::QoS_getVideoInWidth;
*getVideoOutWidth = *tinyWRAPc::QoS_getVideoOutWidth;
*getVideoInHeight = *tinyWRAPc::QoS_getVideoInHeight;
*getVideoOutHeight = *tinyWRAPc::QoS_getVideoOutHeight;
*getBandwidthDownKbps = *tinyWRAPc::QoS_getBandwidthDownKbps;
*getBandwidthUpKbps = *tinyWRAPc::QoS_getBandwidthUpKbps;
*getVideoInAvgFps = *tinyWRAPc::QoS_getVideoInAvgFps;
*getVideoDecAvgTime = *tinyWRAPc::QoS_getVideoDecAvgTime;
*getVideoEncAvgTime = *tinyWRAPc::QoS_getVideoEncAvgTime;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::Codec ##############

package tinyWRAP::Codec;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_Codec($self);
        delete $OWNER{$self};
    }
}

*getMediaType = *tinyWRAPc::Codec_getMediaType;
*getName = *tinyWRAPc::Codec_getName;
*getDescription = *tinyWRAPc::Codec_getDescription;
*getNegFormat = *tinyWRAPc::Codec_getNegFormat;
*getAudioSamplingRate = *tinyWRAPc::Codec_getAudioSamplingRate;
*getAudioChannels = *tinyWRAPc::Codec_getAudioChannels;
*getAudioPTime = *tinyWRAPc::Codec_getAudioPTime;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::MediaSessionMgr ##############

package tinyWRAP::MediaSessionMgr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_MediaSessionMgr($self);
        delete $OWNER{$self};
    }
}

*sessionSetInt32 = *tinyWRAPc::MediaSessionMgr_sessionSetInt32;
*sessionGetInt32 = *tinyWRAPc::MediaSessionMgr_sessionGetInt32;
*sessionGetQoS = *tinyWRAPc::MediaSessionMgr_sessionGetQoS;
*consumerSetInt32 = *tinyWRAPc::MediaSessionMgr_consumerSetInt32;
*consumerSetInt64 = *tinyWRAPc::MediaSessionMgr_consumerSetInt64;
*producerSetInt32 = *tinyWRAPc::MediaSessionMgr_producerSetInt32;
*producerSetInt64 = *tinyWRAPc::MediaSessionMgr_producerSetInt64;
*producerGetCodec = *tinyWRAPc::MediaSessionMgr_producerGetCodec;
*findProxyPluginConsumer = *tinyWRAPc::MediaSessionMgr_findProxyPluginConsumer;
*findProxyPluginProducer = *tinyWRAPc::MediaSessionMgr_findProxyPluginProducer;
*registerAudioPluginFromFile = *tinyWRAPc::MediaSessionMgr_registerAudioPluginFromFile;
*getSessionId = *tinyWRAPc::MediaSessionMgr_getSessionId;
*defaultsSetProfile = *tinyWRAPc::MediaSessionMgr_defaultsSetProfile;
*defaultsGetProfile = *tinyWRAPc::MediaSessionMgr_defaultsGetProfile;
*defaultsSetBandwidthLevel = *tinyWRAPc::MediaSessionMgr_defaultsSetBandwidthLevel;
*defaultsGetBandwidthLevel = *tinyWRAPc::MediaSessionMgr_defaultsGetBandwidthLevel;
*defaultsSetCongestionCtrlEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetCongestionCtrlEnabled;
*defaultsSetVideoMotionRank = *tinyWRAPc::MediaSessionMgr_defaultsSetVideoMotionRank;
*defaultsSetVideoFps = *tinyWRAPc::MediaSessionMgr_defaultsSetVideoFps;
*defaultsSetBandwidthVideoUploadMax = *tinyWRAPc::MediaSessionMgr_defaultsSetBandwidthVideoUploadMax;
*defaultsSetBandwidthVideoDownloadMax = *tinyWRAPc::MediaSessionMgr_defaultsSetBandwidthVideoDownloadMax;
*defaultsSetPrefVideoSize = *tinyWRAPc::MediaSessionMgr_defaultsSetPrefVideoSize;
*defaultsSetPrefVideoSizeOutRange = *tinyWRAPc::MediaSessionMgr_defaultsSetPrefVideoSizeOutRange;
*defaultsSetAdaptativeVideoSizeOutEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetAdaptativeVideoSizeOutEnabled;
*defaultsSetJbMargin = *tinyWRAPc::MediaSessionMgr_defaultsSetJbMargin;
*defaultsSetJbMaxLateRate = *tinyWRAPc::MediaSessionMgr_defaultsSetJbMaxLateRate;
*defaultsSetEchoTail = *tinyWRAPc::MediaSessionMgr_defaultsSetEchoTail;
*defaultsGetEchoTail = *tinyWRAPc::MediaSessionMgr_defaultsGetEchoTail;
*defaultsSetEchoSkew = *tinyWRAPc::MediaSessionMgr_defaultsSetEchoSkew;
*defaultsSetEchoSuppEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetEchoSuppEnabled;
*defaultsGetEchoSuppEnabled = *tinyWRAPc::MediaSessionMgr_defaultsGetEchoSuppEnabled;
*defaultsSetAgcEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetAgcEnabled;
*defaultsGetAgcEnabled = *tinyWRAPc::MediaSessionMgr_defaultsGetAgcEnabled;
*defaultsSetAgcLevel = *tinyWRAPc::MediaSessionMgr_defaultsSetAgcLevel;
*defaultsGetAgcLevel = *tinyWRAPc::MediaSessionMgr_defaultsGetAgcLevel;
*defaultsSetVadEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetVadEnabled;
*defaultsGetGetVadEnabled = *tinyWRAPc::MediaSessionMgr_defaultsGetGetVadEnabled;
*defaultsSetNoiseSuppEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetNoiseSuppEnabled;
*defaultsGetNoiseSuppEnabled = *tinyWRAPc::MediaSessionMgr_defaultsGetNoiseSuppEnabled;
*defaultsSetNoiseSuppLevel = *tinyWRAPc::MediaSessionMgr_defaultsSetNoiseSuppLevel;
*defaultsGetNoiseSuppLevel = *tinyWRAPc::MediaSessionMgr_defaultsGetNoiseSuppLevel;
*defaultsSetConditionalRingingEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetConditionalRingingEnabled;
*defaultsGetConditionalRingingEnabled = *tinyWRAPc::MediaSessionMgr_defaultsGetConditionalRingingEnabled;
*defaultsSet100relEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSet100relEnabled;
*defaultsGet100relEnabled = *tinyWRAPc::MediaSessionMgr_defaultsGet100relEnabled;
*defaultsSetScreenSize = *tinyWRAPc::MediaSessionMgr_defaultsSetScreenSize;
*defaultsSetAudioGain = *tinyWRAPc::MediaSessionMgr_defaultsSetAudioGain;
*defaultsSetAudioPtime = *tinyWRAPc::MediaSessionMgr_defaultsSetAudioPtime;
*defaultsSetAudioChannels = *tinyWRAPc::MediaSessionMgr_defaultsSetAudioChannels;
*defaultsSetRtpPortRange = *tinyWRAPc::MediaSessionMgr_defaultsSetRtpPortRange;
*defaultsSetRtpSymetricEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetRtpSymetricEnabled;
*defaultsSetMediaType = *tinyWRAPc::MediaSessionMgr_defaultsSetMediaType;
*defaultsSetVolume = *tinyWRAPc::MediaSessionMgr_defaultsSetVolume;
*defaultsGetVolume = *tinyWRAPc::MediaSessionMgr_defaultsGetVolume;
*defaultsSetInviteSessionTimers = *tinyWRAPc::MediaSessionMgr_defaultsSetInviteSessionTimers;
*defaultsSetSRtpMode = *tinyWRAPc::MediaSessionMgr_defaultsSetSRtpMode;
*defaultsGetSRtpMode = *tinyWRAPc::MediaSessionMgr_defaultsGetSRtpMode;
*defaultsSetSRtpType = *tinyWRAPc::MediaSessionMgr_defaultsSetSRtpType;
*defaultsGetSRtpType = *tinyWRAPc::MediaSessionMgr_defaultsGetSRtpType;
*defaultsSetRtcpEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetRtcpEnabled;
*defaultsGetRtcpEnabled = *tinyWRAPc::MediaSessionMgr_defaultsGetRtcpEnabled;
*defaultsSetRtcpMuxEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetRtcpMuxEnabled;
*defaultsGetRtcpMuxEnabled = *tinyWRAPc::MediaSessionMgr_defaultsGetRtcpMuxEnabled;
*defaultsSetStunEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetStunEnabled;
*defaultsSetIceStunEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetIceStunEnabled;
*defaultsSetIceTurnEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetIceTurnEnabled;
*defaultsSetStunServer = *tinyWRAPc::MediaSessionMgr_defaultsSetStunServer;
*defaultsSetStunCred = *tinyWRAPc::MediaSessionMgr_defaultsSetStunCred;
*defaultsSetIceEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetIceEnabled;
*defaultsSetByPassEncoding = *tinyWRAPc::MediaSessionMgr_defaultsSetByPassEncoding;
*defaultsGetByPassEncoding = *tinyWRAPc::MediaSessionMgr_defaultsGetByPassEncoding;
*defaultsSetByPassDecoding = *tinyWRAPc::MediaSessionMgr_defaultsSetByPassDecoding;
*defaultsGetByPassDecoding = *tinyWRAPc::MediaSessionMgr_defaultsGetByPassDecoding;
*defaultsSetVideoJbEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetVideoJbEnabled;
*defaultsGetVideoJbEnabled = *tinyWRAPc::MediaSessionMgr_defaultsGetVideoJbEnabled;
*defaultsSetVideoZeroArtifactsEnabled = *tinyWRAPc::MediaSessionMgr_defaultsSetVideoZeroArtifactsEnabled;
*defaultsGetVideoZeroArtifactsEnabled = *tinyWRAPc::MediaSessionMgr_defaultsGetVideoZeroArtifactsEnabled;
*defaultsSetRtpBuffSize = *tinyWRAPc::MediaSessionMgr_defaultsSetRtpBuffSize;
*defaultsGetRtpBuffSize = *tinyWRAPc::MediaSessionMgr_defaultsGetRtpBuffSize;
*defaultsSetAvpfTail = *tinyWRAPc::MediaSessionMgr_defaultsSetAvpfTail;
*defaultsSetAvpfMode = *tinyWRAPc::MediaSessionMgr_defaultsSetAvpfMode;
*defaultsSetOpusMaxCaptureRate = *tinyWRAPc::MediaSessionMgr_defaultsSetOpusMaxCaptureRate;
*defaultsSetOpusMaxPlaybackRate = *tinyWRAPc::MediaSessionMgr_defaultsSetOpusMaxPlaybackRate;
*defaultsSetMaxFds = *tinyWRAPc::MediaSessionMgr_defaultsSetMaxFds;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::MediaContent ##############

package tinyWRAP::MediaContent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_MediaContent($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::MediaContent_getType;
*getDataLength = *tinyWRAPc::MediaContent_getDataLength;
*getData = *tinyWRAPc::MediaContent_getData;
*parse = *tinyWRAPc::MediaContent_parse;
*getPayloadLength = *tinyWRAPc::MediaContent_getPayloadLength;
*getPayload = *tinyWRAPc::MediaContent_getPayload;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::MediaContentCPIM ##############

package tinyWRAP::MediaContentCPIM;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::MediaContent tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_MediaContentCPIM($self);
        delete $OWNER{$self};
    }
}

*getPayloadLength = *tinyWRAPc::MediaContentCPIM_getPayloadLength;
*getPayload = *tinyWRAPc::MediaContentCPIM_getPayload;
*getHeaderValue = *tinyWRAPc::MediaContentCPIM_getHeaderValue;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SipUri ##############

package tinyWRAP::SipUri;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_SipUri(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SipUri($self);
        delete $OWNER{$self};
    }
}

*isValid = *tinyWRAPc::SipUri_isValid;
*getScheme = *tinyWRAPc::SipUri_getScheme;
*getHost = *tinyWRAPc::SipUri_getHost;
*getPort = *tinyWRAPc::SipUri_getPort;
*getUserName = *tinyWRAPc::SipUri_getUserName;
*getPassword = *tinyWRAPc::SipUri_getPassword;
*getDisplayName = *tinyWRAPc::SipUri_getDisplayName;
*getParamValue = *tinyWRAPc::SipUri_getParamValue;
*setDisplayName = *tinyWRAPc::SipUri_setDisplayName;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SdpMessage ##############

package tinyWRAP::SdpMessage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_SdpMessage(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SdpMessage($self);
        delete $OWNER{$self};
    }
}

*getSdpHeaderValue = *tinyWRAPc::SdpMessage_getSdpHeaderValue;
*getSdpHeaderAValue = *tinyWRAPc::SdpMessage_getSdpHeaderAValue;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SipMessage ##############

package tinyWRAP::SipMessage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_SipMessage(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SipMessage($self);
        delete $OWNER{$self};
    }
}

*isResponse = *tinyWRAPc::SipMessage_isResponse;
*getRequestType = *tinyWRAPc::SipMessage_getRequestType;
*getResponseCode = *tinyWRAPc::SipMessage_getResponseCode;
*getResponsePhrase = *tinyWRAPc::SipMessage_getResponsePhrase;
*getSipHeaderValue = *tinyWRAPc::SipMessage_getSipHeaderValue;
*getSipHeaderParamValue = *tinyWRAPc::SipMessage_getSipHeaderParamValue;
*getSipContentLength = *tinyWRAPc::SipMessage_getSipContentLength;
*getSipContent = *tinyWRAPc::SipMessage_getSipContent;
*getSdpMessage = *tinyWRAPc::SipMessage_getSdpMessage;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SipEvent ##############

package tinyWRAP::SipEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SipEvent($self);
        delete $OWNER{$self};
    }
}

*getCode = *tinyWRAPc::SipEvent_getCode;
*getPhrase = *tinyWRAPc::SipEvent_getPhrase;
*getBaseSession = *tinyWRAPc::SipEvent_getBaseSession;
*getSipMessage = *tinyWRAPc::SipEvent_getSipMessage;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::DialogEvent ##############

package tinyWRAP::DialogEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipEvent tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_DialogEvent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::StackEvent ##############

package tinyWRAP::StackEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipEvent tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_StackEvent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::InviteEvent ##############

package tinyWRAP::InviteEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipEvent tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_InviteEvent($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::InviteEvent_getType;
*getMediaType = *tinyWRAPc::InviteEvent_getMediaType;
*getSession = *tinyWRAPc::InviteEvent_getSession;
*takeCallSessionOwnership = *tinyWRAPc::InviteEvent_takeCallSessionOwnership;
*takeMsrpSessionOwnership = *tinyWRAPc::InviteEvent_takeMsrpSessionOwnership;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::MessagingEvent ##############

package tinyWRAP::MessagingEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipEvent tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_MessagingEvent($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::MessagingEvent_getType;
*getSession = *tinyWRAPc::MessagingEvent_getSession;
*takeSessionOwnership = *tinyWRAPc::MessagingEvent_takeSessionOwnership;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::InfoEvent ##############

package tinyWRAP::InfoEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipEvent tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_InfoEvent($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::InfoEvent_getType;
*getSession = *tinyWRAPc::InfoEvent_getSession;
*takeSessionOwnership = *tinyWRAPc::InfoEvent_takeSessionOwnership;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::OptionsEvent ##############

package tinyWRAP::OptionsEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipEvent tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_OptionsEvent($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::OptionsEvent_getType;
*getSession = *tinyWRAPc::OptionsEvent_getSession;
*takeSessionOwnership = *tinyWRAPc::OptionsEvent_takeSessionOwnership;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::PublicationEvent ##############

package tinyWRAP::PublicationEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipEvent tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_PublicationEvent($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::PublicationEvent_getType;
*getSession = *tinyWRAPc::PublicationEvent_getSession;
*takeSessionOwnership = *tinyWRAPc::PublicationEvent_takeSessionOwnership;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::RegistrationEvent ##############

package tinyWRAP::RegistrationEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipEvent tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_RegistrationEvent($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::RegistrationEvent_getType;
*getSession = *tinyWRAPc::RegistrationEvent_getSession;
*takeSessionOwnership = *tinyWRAPc::RegistrationEvent_takeSessionOwnership;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SubscriptionEvent ##############

package tinyWRAP::SubscriptionEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipEvent tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SubscriptionEvent($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::SubscriptionEvent_getType;
*getSession = *tinyWRAPc::SubscriptionEvent_getSession;
*takeSessionOwnership = *tinyWRAPc::SubscriptionEvent_takeSessionOwnership;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::T140CallbackData ##############

package tinyWRAP::T140CallbackData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_T140CallbackData($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::T140CallbackData_getType;
*getSize = *tinyWRAPc::T140CallbackData_getSize;
*getData = *tinyWRAPc::T140CallbackData_getData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::T140Callback ##############

package tinyWRAP::T140Callback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_T140Callback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_T140Callback($self);
        delete $OWNER{$self};
    }
}

*ondata = *tinyWRAPc::T140Callback_ondata;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SipSession ##############

package tinyWRAP::SipSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_SipSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SipSession($self);
        delete $OWNER{$self};
    }
}

*haveOwnership = *tinyWRAPc::SipSession_haveOwnership;
*addHeader = *tinyWRAPc::SipSession_addHeader;
*removeHeader = *tinyWRAPc::SipSession_removeHeader;
*addCaps = *tinyWRAPc::SipSession_addCaps;
*removeCaps = *tinyWRAPc::SipSession_removeCaps;
*setExpires = *tinyWRAPc::SipSession_setExpires;
*setFromUri = *tinyWRAPc::SipSession_setFromUri;
*setToUri = *tinyWRAPc::SipSession_setToUri;
*setSilentHangup = *tinyWRAPc::SipSession_setSilentHangup;
*addSigCompCompartment = *tinyWRAPc::SipSession_addSigCompCompartment;
*removeSigCompCompartment = *tinyWRAPc::SipSession_removeSigCompCompartment;
*getId = *tinyWRAPc::SipSession_getId;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::InviteSession ##############

package tinyWRAP::InviteSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipSession tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_InviteSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_InviteSession($self);
        delete $OWNER{$self};
    }
}

*accept = *tinyWRAPc::InviteSession_accept;
*hangup = *tinyWRAPc::InviteSession_hangup;
*reject = *tinyWRAPc::InviteSession_reject;
*sendInfo = *tinyWRAPc::InviteSession_sendInfo;
*getMediaMgr = *tinyWRAPc::InviteSession_getMediaMgr;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::CallSession ##############

package tinyWRAP::CallSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::InviteSession tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_CallSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_CallSession($self);
        delete $OWNER{$self};
    }
}

*callAudio = *tinyWRAPc::CallSession_callAudio;
*callAudioVideo = *tinyWRAPc::CallSession_callAudioVideo;
*callVideo = *tinyWRAPc::CallSession_callVideo;
*call = *tinyWRAPc::CallSession_call;
*setSessionTimer = *tinyWRAPc::CallSession_setSessionTimer;
*set100rel = *tinyWRAPc::CallSession_set100rel;
*setRtcp = *tinyWRAPc::CallSession_setRtcp;
*setRtcpMux = *tinyWRAPc::CallSession_setRtcpMux;
*setSRtpMode = *tinyWRAPc::CallSession_setSRtpMode;
*setAvpfMode = *tinyWRAPc::CallSession_setAvpfMode;
*setICE = *tinyWRAPc::CallSession_setICE;
*setICEStun = *tinyWRAPc::CallSession_setICEStun;
*setICETurn = *tinyWRAPc::CallSession_setICETurn;
*setSTUNServer = *tinyWRAPc::CallSession_setSTUNServer;
*setSTUNCred = *tinyWRAPc::CallSession_setSTUNCred;
*setVideoFps = *tinyWRAPc::CallSession_setVideoFps;
*setVideoBandwidthUploadMax = *tinyWRAPc::CallSession_setVideoBandwidthUploadMax;
*setVideoBandwidthDownloadMax = *tinyWRAPc::CallSession_setVideoBandwidthDownloadMax;
*setVideoPrefSize = *tinyWRAPc::CallSession_setVideoPrefSize;
*setQoS = *tinyWRAPc::CallSession_setQoS;
*hold = *tinyWRAPc::CallSession_hold;
*resume = *tinyWRAPc::CallSession_resume;
*transfer = *tinyWRAPc::CallSession_transfer;
*acceptTransfer = *tinyWRAPc::CallSession_acceptTransfer;
*rejectTransfer = *tinyWRAPc::CallSession_rejectTransfer;
*sendDTMF = *tinyWRAPc::CallSession_sendDTMF;
*getSessionTransferId = *tinyWRAPc::CallSession_getSessionTransferId;
*sendT140Data = *tinyWRAPc::CallSession_sendT140Data;
*setT140Callback = *tinyWRAPc::CallSession_setT140Callback;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::MsrpSession ##############

package tinyWRAP::MsrpSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::InviteSession tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_MsrpSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_MsrpSession($self);
        delete $OWNER{$self};
    }
}

*setCallback = *tinyWRAPc::MsrpSession_setCallback;
*callMsrp = *tinyWRAPc::MsrpSession_callMsrp;
*sendMessage = *tinyWRAPc::MsrpSession_sendMessage;
*sendFile = *tinyWRAPc::MsrpSession_sendFile;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::MessagingSession ##############

package tinyWRAP::MessagingSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipSession tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_MessagingSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_MessagingSession($self);
        delete $OWNER{$self};
    }
}

*send = *tinyWRAPc::MessagingSession_send;
*accept = *tinyWRAPc::MessagingSession_accept;
*reject = *tinyWRAPc::MessagingSession_reject;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::InfoSession ##############

package tinyWRAP::InfoSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipSession tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_InfoSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_InfoSession($self);
        delete $OWNER{$self};
    }
}

*send = *tinyWRAPc::InfoSession_send;
*accept = *tinyWRAPc::InfoSession_accept;
*reject = *tinyWRAPc::InfoSession_reject;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::OptionsSession ##############

package tinyWRAP::OptionsSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipSession tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_OptionsSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_OptionsSession($self);
        delete $OWNER{$self};
    }
}

*send = *tinyWRAPc::OptionsSession_send;
*accept = *tinyWRAPc::OptionsSession_accept;
*reject = *tinyWRAPc::OptionsSession_reject;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::PublicationSession ##############

package tinyWRAP::PublicationSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipSession tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_PublicationSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_PublicationSession($self);
        delete $OWNER{$self};
    }
}

*publish = *tinyWRAPc::PublicationSession_publish;
*unPublish = *tinyWRAPc::PublicationSession_unPublish;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::RegistrationSession ##############

package tinyWRAP::RegistrationSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipSession tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_RegistrationSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_RegistrationSession($self);
        delete $OWNER{$self};
    }
}

*register_ = *tinyWRAPc::RegistrationSession_register_;
*unRegister = *tinyWRAPc::RegistrationSession_unRegister;
*accept = *tinyWRAPc::RegistrationSession_accept;
*reject = *tinyWRAPc::RegistrationSession_reject;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SubscriptionSession ##############

package tinyWRAP::SubscriptionSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SipSession tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_SubscriptionSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SubscriptionSession($self);
        delete $OWNER{$self};
    }
}

*subscribe = *tinyWRAPc::SubscriptionSession_subscribe;
*unSubscribe = *tinyWRAPc::SubscriptionSession_unSubscribe;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyPluginMgr ##############

package tinyWRAP::ProxyPluginMgr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyPluginMgr($self);
        delete $OWNER{$self};
    }
}

*createInstance = *tinyWRAPc::ProxyPluginMgr_createInstance;
*getInstance = *tinyWRAPc::ProxyPluginMgr_getInstance;
*findPlugin = *tinyWRAPc::ProxyPluginMgr_findPlugin;
*findAudioConsumer = *tinyWRAPc::ProxyPluginMgr_findAudioConsumer;
*findVideoConsumer = *tinyWRAPc::ProxyPluginMgr_findVideoConsumer;
*findAudioProducer = *tinyWRAPc::ProxyPluginMgr_findAudioProducer;
*findVideoProducer = *tinyWRAPc::ProxyPluginMgr_findVideoProducer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyPluginMgrCallback ##############

package tinyWRAP::ProxyPluginMgrCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_ProxyPluginMgrCallback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyPluginMgrCallback($self);
        delete $OWNER{$self};
    }
}

*OnPluginCreated = *tinyWRAPc::ProxyPluginMgrCallback_OnPluginCreated;
*OnPluginDestroyed = *tinyWRAPc::ProxyPluginMgrCallback_OnPluginDestroyed;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyPlugin ##############

package tinyWRAP::ProxyPlugin;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyPlugin($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::ProxyPlugin_getType;
*getId = *tinyWRAPc::ProxyPlugin_getId;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyAudioConsumerCallback ##############

package tinyWRAP::ProxyAudioConsumerCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_ProxyAudioConsumerCallback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyAudioConsumerCallback($self);
        delete $OWNER{$self};
    }
}

*prepare = *tinyWRAPc::ProxyAudioConsumerCallback_prepare;
*start = *tinyWRAPc::ProxyAudioConsumerCallback_start;
*pause = *tinyWRAPc::ProxyAudioConsumerCallback_pause;
*stop = *tinyWRAPc::ProxyAudioConsumerCallback_stop;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyAudioConsumer ##############

package tinyWRAP::ProxyAudioConsumer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::ProxyPlugin tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyAudioConsumer($self);
        delete $OWNER{$self};
    }
}

*setActualSndCardPlaybackParams = *tinyWRAPc::ProxyAudioConsumer_setActualSndCardPlaybackParams;
*queryForResampler = *tinyWRAPc::ProxyAudioConsumer_queryForResampler;
*setPullBuffer = *tinyWRAPc::ProxyAudioConsumer_setPullBuffer;
*pull = *tinyWRAPc::ProxyAudioConsumer_pull;
*setGain = *tinyWRAPc::ProxyAudioConsumer_setGain;
*getGain = *tinyWRAPc::ProxyAudioConsumer_getGain;
*reset = *tinyWRAPc::ProxyAudioConsumer_reset;
*setCallback = *tinyWRAPc::ProxyAudioConsumer_setCallback;
*getMediaSessionId = *tinyWRAPc::ProxyAudioConsumer_getMediaSessionId;
*registerPlugin = *tinyWRAPc::ProxyAudioConsumer_registerPlugin;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyVideoConsumerCallback ##############

package tinyWRAP::ProxyVideoConsumerCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_ProxyVideoConsumerCallback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyVideoConsumerCallback($self);
        delete $OWNER{$self};
    }
}

*prepare = *tinyWRAPc::ProxyVideoConsumerCallback_prepare;
*consume = *tinyWRAPc::ProxyVideoConsumerCallback_consume;
*bufferCopied = *tinyWRAPc::ProxyVideoConsumerCallback_bufferCopied;
*start = *tinyWRAPc::ProxyVideoConsumerCallback_start;
*pause = *tinyWRAPc::ProxyVideoConsumerCallback_pause;
*stop = *tinyWRAPc::ProxyVideoConsumerCallback_stop;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyVideoConsumer ##############

package tinyWRAP::ProxyVideoConsumer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::ProxyPlugin tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyVideoConsumer($self);
        delete $OWNER{$self};
    }
}

*setDisplaySize = *tinyWRAPc::ProxyVideoConsumer_setDisplaySize;
*getDisplayWidth = *tinyWRAPc::ProxyVideoConsumer_getDisplayWidth;
*getDisplayHeight = *tinyWRAPc::ProxyVideoConsumer_getDisplayHeight;
*getDecodedWidth = *tinyWRAPc::ProxyVideoConsumer_getDecodedWidth;
*getDecodedHeight = *tinyWRAPc::ProxyVideoConsumer_getDecodedHeight;
*setCallback = *tinyWRAPc::ProxyVideoConsumer_setCallback;
*setAutoResizeDisplay = *tinyWRAPc::ProxyVideoConsumer_setAutoResizeDisplay;
*getAutoResizeDisplay = *tinyWRAPc::ProxyVideoConsumer_getAutoResizeDisplay;
*setConsumeBuffer = *tinyWRAPc::ProxyVideoConsumer_setConsumeBuffer;
*pull = *tinyWRAPc::ProxyVideoConsumer_pull;
*reset = *tinyWRAPc::ProxyVideoConsumer_reset;
*getMediaSessionId = *tinyWRAPc::ProxyVideoConsumer_getMediaSessionId;
*registerPlugin = *tinyWRAPc::ProxyVideoConsumer_registerPlugin;
*setDefaultChroma = *tinyWRAPc::ProxyVideoConsumer_setDefaultChroma;
*setDefaultAutoResizeDisplay = *tinyWRAPc::ProxyVideoConsumer_setDefaultAutoResizeDisplay;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyVideoFrame ##############

package tinyWRAP::ProxyVideoFrame;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyVideoFrame($self);
        delete $OWNER{$self};
    }
}

*getSize = *tinyWRAPc::ProxyVideoFrame_getSize;
*getContent = *tinyWRAPc::ProxyVideoFrame_getContent;
*getFrameWidth = *tinyWRAPc::ProxyVideoFrame_getFrameWidth;
*getFrameHeight = *tinyWRAPc::ProxyVideoFrame_getFrameHeight;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyAudioProducerCallback ##############

package tinyWRAP::ProxyAudioProducerCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_ProxyAudioProducerCallback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyAudioProducerCallback($self);
        delete $OWNER{$self};
    }
}

*prepare = *tinyWRAPc::ProxyAudioProducerCallback_prepare;
*start = *tinyWRAPc::ProxyAudioProducerCallback_start;
*pause = *tinyWRAPc::ProxyAudioProducerCallback_pause;
*stop = *tinyWRAPc::ProxyAudioProducerCallback_stop;
*fillPushBuffer = *tinyWRAPc::ProxyAudioProducerCallback_fillPushBuffer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyAudioProducer ##############

package tinyWRAP::ProxyAudioProducer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::ProxyPlugin tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyAudioProducer($self);
        delete $OWNER{$self};
    }
}

*setActualSndCardRecordParams = *tinyWRAPc::ProxyAudioProducer_setActualSndCardRecordParams;
*setPushBuffer = *tinyWRAPc::ProxyAudioProducer_setPushBuffer;
*push = *tinyWRAPc::ProxyAudioProducer_push;
*setGain = *tinyWRAPc::ProxyAudioProducer_setGain;
*getGain = *tinyWRAPc::ProxyAudioProducer_getGain;
*setCallback = *tinyWRAPc::ProxyAudioProducer_setCallback;
*getMediaSessionId = *tinyWRAPc::ProxyAudioProducer_getMediaSessionId;
*registerPlugin = *tinyWRAPc::ProxyAudioProducer_registerPlugin;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyVideoProducerCallback ##############

package tinyWRAP::ProxyVideoProducerCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_ProxyVideoProducerCallback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyVideoProducerCallback($self);
        delete $OWNER{$self};
    }
}

*prepare = *tinyWRAPc::ProxyVideoProducerCallback_prepare;
*start = *tinyWRAPc::ProxyVideoProducerCallback_start;
*pause = *tinyWRAPc::ProxyVideoProducerCallback_pause;
*stop = *tinyWRAPc::ProxyVideoProducerCallback_stop;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::ProxyVideoProducer ##############

package tinyWRAP::ProxyVideoProducer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::ProxyPlugin tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_ProxyVideoProducer($self);
        delete $OWNER{$self};
    }
}

*getRotation = *tinyWRAPc::ProxyVideoProducer_getRotation;
*setRotation = *tinyWRAPc::ProxyVideoProducer_setRotation;
*getMirror = *tinyWRAPc::ProxyVideoProducer_getMirror;
*setMirror = *tinyWRAPc::ProxyVideoProducer_setMirror;
*setActualCameraOutputSize = *tinyWRAPc::ProxyVideoProducer_setActualCameraOutputSize;
*push = *tinyWRAPc::ProxyVideoProducer_push;
*setCallback = *tinyWRAPc::ProxyVideoProducer_setCallback;
*getMediaSessionId = *tinyWRAPc::ProxyVideoProducer_getMediaSessionId;
*registerPlugin = *tinyWRAPc::ProxyVideoProducer_registerPlugin;
*setDefaultChroma = *tinyWRAPc::ProxyVideoProducer_setDefaultChroma;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SipCallback ##############

package tinyWRAP::SipCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_SipCallback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SipCallback($self);
        delete $OWNER{$self};
    }
}

*OnDialogEvent = *tinyWRAPc::SipCallback_OnDialogEvent;
*OnStackEvent = *tinyWRAPc::SipCallback_OnStackEvent;
*OnInviteEvent = *tinyWRAPc::SipCallback_OnInviteEvent;
*OnMessagingEvent = *tinyWRAPc::SipCallback_OnMessagingEvent;
*OnInfoEvent = *tinyWRAPc::SipCallback_OnInfoEvent;
*OnOptionsEvent = *tinyWRAPc::SipCallback_OnOptionsEvent;
*OnPublicationEvent = *tinyWRAPc::SipCallback_OnPublicationEvent;
*OnRegistrationEvent = *tinyWRAPc::SipCallback_OnRegistrationEvent;
*OnSubscriptionEvent = *tinyWRAPc::SipCallback_OnSubscriptionEvent;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SafeObject ##############

package tinyWRAP::SafeObject;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_SafeObject(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SafeObject($self);
        delete $OWNER{$self};
    }
}

*Lock = *tinyWRAPc::SafeObject_Lock;
*UnLock = *tinyWRAPc::SafeObject_UnLock;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SipStack ##############

package tinyWRAP::SipStack;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP::SafeObject tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_SipStack(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SipStack($self);
        delete $OWNER{$self};
    }
}

*start = *tinyWRAPc::SipStack_start;
*setDebugCallback = *tinyWRAPc::SipStack_setDebugCallback;
*setDisplayName = *tinyWRAPc::SipStack_setDisplayName;
*setRealm = *tinyWRAPc::SipStack_setRealm;
*setIMPI = *tinyWRAPc::SipStack_setIMPI;
*setIMPU = *tinyWRAPc::SipStack_setIMPU;
*setPassword = *tinyWRAPc::SipStack_setPassword;
*setAMF = *tinyWRAPc::SipStack_setAMF;
*setOperatorId = *tinyWRAPc::SipStack_setOperatorId;
*setProxyCSCF = *tinyWRAPc::SipStack_setProxyCSCF;
*setLocalIP = *tinyWRAPc::SipStack_setLocalIP;
*setLocalPort = *tinyWRAPc::SipStack_setLocalPort;
*setEarlyIMS = *tinyWRAPc::SipStack_setEarlyIMS;
*addHeader = *tinyWRAPc::SipStack_addHeader;
*removeHeader = *tinyWRAPc::SipStack_removeHeader;
*addDnsServer = *tinyWRAPc::SipStack_addDnsServer;
*setDnsDiscovery = *tinyWRAPc::SipStack_setDnsDiscovery;
*setAoR = *tinyWRAPc::SipStack_setAoR;
*setSigCompParams = *tinyWRAPc::SipStack_setSigCompParams;
*addSigCompCompartment = *tinyWRAPc::SipStack_addSigCompCompartment;
*removeSigCompCompartment = *tinyWRAPc::SipStack_removeSigCompCompartment;
*setSTUNEnabledForICE = *tinyWRAPc::SipStack_setSTUNEnabledForICE;
*setSTUNServer = *tinyWRAPc::SipStack_setSTUNServer;
*setSTUNCred = *tinyWRAPc::SipStack_setSTUNCred;
*setSTUNEnabled = *tinyWRAPc::SipStack_setSTUNEnabled;
*setTLSSecAgree = *tinyWRAPc::SipStack_setTLSSecAgree;
*setSSLCertificates = *tinyWRAPc::SipStack_setSSLCertificates;
*setSSLCretificates = *tinyWRAPc::SipStack_setSSLCretificates;
*setIPSecSecAgree = *tinyWRAPc::SipStack_setIPSecSecAgree;
*setIPSecParameters = *tinyWRAPc::SipStack_setIPSecParameters;
*dnsENUM = *tinyWRAPc::SipStack_dnsENUM;
*dnsNaptrSrv = *tinyWRAPc::SipStack_dnsNaptrSrv;
*dnsSrv = *tinyWRAPc::SipStack_dnsSrv;
*setMaxFDs = *tinyWRAPc::SipStack_setMaxFDs;
*getLocalIPnPort = *tinyWRAPc::SipStack_getLocalIPnPort;
*getPreferredIdentity = *tinyWRAPc::SipStack_getPreferredIdentity;
*isValid = *tinyWRAPc::SipStack_isValid;
*stop = *tinyWRAPc::SipStack_stop;
*initialize = *tinyWRAPc::SipStack_initialize;
*deInitialize = *tinyWRAPc::SipStack_deInitialize;
*setCodecs = *tinyWRAPc::SipStack_setCodecs;
*setCodecs_2 = *tinyWRAPc::SipStack_setCodecs_2;
*setCodecPriority = *tinyWRAPc::SipStack_setCodecPriority;
*setCodecPriority_2 = *tinyWRAPc::SipStack_setCodecPriority_2;
*isCodecSupported = *tinyWRAPc::SipStack_isCodecSupported;
*isIPSecSupported = *tinyWRAPc::SipStack_isIPSecSupported;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::XcapSelector ##############

package tinyWRAP::XcapSelector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_XcapSelector(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_XcapSelector($self);
        delete $OWNER{$self};
    }
}

*setAUID = *tinyWRAPc::XcapSelector_setAUID;
*setName = *tinyWRAPc::XcapSelector_setName;
*setAttribute = *tinyWRAPc::XcapSelector_setAttribute;
*setPos = *tinyWRAPc::XcapSelector_setPos;
*setPosAttribute = *tinyWRAPc::XcapSelector_setPosAttribute;
*setNamespace = *tinyWRAPc::XcapSelector_setNamespace;
*getString = *tinyWRAPc::XcapSelector_getString;
*reset = *tinyWRAPc::XcapSelector_reset;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::XcapMessage ##############

package tinyWRAP::XcapMessage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_XcapMessage(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_XcapMessage($self);
        delete $OWNER{$self};
    }
}

*getCode = *tinyWRAPc::XcapMessage_getCode;
*getPhrase = *tinyWRAPc::XcapMessage_getPhrase;
*getXcapHeaderValue = *tinyWRAPc::XcapMessage_getXcapHeaderValue;
*getXcapHeaderParamValue = *tinyWRAPc::XcapMessage_getXcapHeaderParamValue;
*getXcapContentLength = *tinyWRAPc::XcapMessage_getXcapContentLength;
*getXcapContent = *tinyWRAPc::XcapMessage_getXcapContent;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::XcapEvent ##############

package tinyWRAP::XcapEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_XcapEvent($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::XcapEvent_getType;
*getXcapMessage = *tinyWRAPc::XcapEvent_getXcapMessage;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::XcapCallback ##############

package tinyWRAP::XcapCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_XcapCallback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_XcapCallback($self);
        delete $OWNER{$self};
    }
}

*onEvent = *tinyWRAPc::XcapCallback_onEvent;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::XcapStack ##############

package tinyWRAP::XcapStack;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_XcapStack(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_XcapStack($self);
        delete $OWNER{$self};
    }
}

*registerAUID = *tinyWRAPc::XcapStack_registerAUID;
*start = *tinyWRAPc::XcapStack_start;
*setCredentials = *tinyWRAPc::XcapStack_setCredentials;
*setXcapRoot = *tinyWRAPc::XcapStack_setXcapRoot;
*setLocalIP = *tinyWRAPc::XcapStack_setLocalIP;
*setLocalPort = *tinyWRAPc::XcapStack_setLocalPort;
*addHeader = *tinyWRAPc::XcapStack_addHeader;
*removeHeader = *tinyWRAPc::XcapStack_removeHeader;
*setTimeout = *tinyWRAPc::XcapStack_setTimeout;
*getDocument = *tinyWRAPc::XcapStack_getDocument;
*getElement = *tinyWRAPc::XcapStack_getElement;
*getAttribute = *tinyWRAPc::XcapStack_getAttribute;
*deleteDocument = *tinyWRAPc::XcapStack_deleteDocument;
*deleteElement = *tinyWRAPc::XcapStack_deleteElement;
*deleteAttribute = *tinyWRAPc::XcapStack_deleteAttribute;
*putDocument = *tinyWRAPc::XcapStack_putDocument;
*putElement = *tinyWRAPc::XcapStack_putElement;
*putAttribute = *tinyWRAPc::XcapStack_putAttribute;
*stop = *tinyWRAPc::XcapStack_stop;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::RPMessage ##############

package tinyWRAP::RPMessage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_RPMessage(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_RPMessage($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::RPMessage_getType;
*getPayloadLength = *tinyWRAPc::RPMessage_getPayloadLength;
*getPayload = *tinyWRAPc::RPMessage_getPayload;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SMSData ##############

package tinyWRAP::SMSData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_SMSData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SMSData($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::SMSData_getType;
*getMR = *tinyWRAPc::SMSData_getMR;
*getPayloadLength = *tinyWRAPc::SMSData_getPayloadLength;
*getPayload = *tinyWRAPc::SMSData_getPayload;
*getOA = *tinyWRAPc::SMSData_getOA;
*getDA = *tinyWRAPc::SMSData_getDA;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::SMSEncoder ##############

package tinyWRAP::SMSEncoder;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
*encodeSubmit = *tinyWRAPc::SMSEncoder_encodeSubmit;
*encodeDeliver = *tinyWRAPc::SMSEncoder_encodeDeliver;
*encodeACK = *tinyWRAPc::SMSEncoder_encodeACK;
*encodeError = *tinyWRAPc::SMSEncoder_encodeError;
*decode = *tinyWRAPc::SMSEncoder_decode;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_SMSEncoder($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::MsrpMessage ##############

package tinyWRAP::MsrpMessage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_MsrpMessage(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_MsrpMessage($self);
        delete $OWNER{$self};
    }
}

*isRequest = *tinyWRAPc::MsrpMessage_isRequest;
*getCode = *tinyWRAPc::MsrpMessage_getCode;
*getPhrase = *tinyWRAPc::MsrpMessage_getPhrase;
*getRequestType = *tinyWRAPc::MsrpMessage_getRequestType;
*getByteRange = *tinyWRAPc::MsrpMessage_getByteRange;
*isLastChunck = *tinyWRAPc::MsrpMessage_isLastChunck;
*isFirstChunck = *tinyWRAPc::MsrpMessage_isFirstChunck;
*isSuccessReport = *tinyWRAPc::MsrpMessage_isSuccessReport;
*getMsrpHeaderValue = *tinyWRAPc::MsrpMessage_getMsrpHeaderValue;
*getMsrpHeaderParamValue = *tinyWRAPc::MsrpMessage_getMsrpHeaderParamValue;
*getMsrpContentLength = *tinyWRAPc::MsrpMessage_getMsrpContentLength;
*getMsrpContent = *tinyWRAPc::MsrpMessage_getMsrpContent;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::MsrpEvent ##############

package tinyWRAP::MsrpEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_MsrpEvent($self);
        delete $OWNER{$self};
    }
}

*getType = *tinyWRAPc::MsrpEvent_getType;
*getSipSession = *tinyWRAPc::MsrpEvent_getSipSession;
*getMessage = *tinyWRAPc::MsrpEvent_getMessage;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : tinyWRAP::MsrpCallback ##############

package tinyWRAP::MsrpCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( tinyWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = tinyWRAPc::new_MsrpCallback(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        tinyWRAPc::delete_MsrpCallback($self);
        delete $OWNER{$self};
    }
}

*OnEvent = *tinyWRAPc::MsrpCallback_OnEvent;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package tinyWRAP;

*twrap_media_none = *tinyWRAPc::twrap_media_none;
*twrap_media_audio = *tinyWRAPc::twrap_media_audio;
*twrap_media_video = *tinyWRAPc::twrap_media_video;
*twrap_media_msrp = *tinyWRAPc::twrap_media_msrp;
*twrap_media_t140 = *tinyWRAPc::twrap_media_t140;
*twrap_media_bfcp = *tinyWRAPc::twrap_media_bfcp;
*twrap_media_bfcp_audio = *tinyWRAPc::twrap_media_bfcp_audio;
*twrap_media_bfcp_video = *tinyWRAPc::twrap_media_bfcp_video;
*twrap_media_audiovideo = *tinyWRAPc::twrap_media_audiovideo;
*twrap_media_audio_video = *tinyWRAPc::twrap_media_audio_video;
*twrap_proxy_plugin_audio_producer = *tinyWRAPc::twrap_proxy_plugin_audio_producer;
*twrap_proxy_plugin_video_producer = *tinyWRAPc::twrap_proxy_plugin_video_producer;
*twrap_proxy_plugin_audio_consumer = *tinyWRAPc::twrap_proxy_plugin_audio_consumer;
*twrap_proxy_plugin_video_consumer = *tinyWRAPc::twrap_proxy_plugin_video_consumer;
*tsip_stack_mode_ua = *tinyWRAPc::tsip_stack_mode_ua;
*tsip_stack_mode_p2p = *tinyWRAPc::tsip_stack_mode_p2p;
*tsip_stack_mode_mediaproxy = *tinyWRAPc::tsip_stack_mode_mediaproxy;
*tsip_stack_mode_mcu = *tinyWRAPc::tsip_stack_mode_mcu;
*tsip_NONE = *tinyWRAPc::tsip_NONE;
*tsip_ACK = *tinyWRAPc::tsip_ACK;
*tsip_BYE = *tinyWRAPc::tsip_BYE;
*tsip_CANCEL = *tinyWRAPc::tsip_CANCEL;
*tsip_INVITE = *tinyWRAPc::tsip_INVITE;
*tsip_OPTIONS = *tinyWRAPc::tsip_OPTIONS;
*tsip_REGISTER = *tinyWRAPc::tsip_REGISTER;
*tsip_SUBSCRIBE = *tinyWRAPc::tsip_SUBSCRIBE;
*tsip_NOTIFY = *tinyWRAPc::tsip_NOTIFY;
*tsip_REFER = *tinyWRAPc::tsip_REFER;
*tsip_INFO = *tinyWRAPc::tsip_INFO;
*tsip_UPDATE = *tinyWRAPc::tsip_UPDATE;
*tsip_MESSAGE = *tinyWRAPc::tsip_MESSAGE;
*tsip_PUBLISH = *tinyWRAPc::tsip_PUBLISH;
*tsip_PRACK = *tinyWRAPc::tsip_PRACK;
*tsip_event_invite = *tinyWRAPc::tsip_event_invite;
*tsip_event_message = *tinyWRAPc::tsip_event_message;
*tsip_event_info = *tinyWRAPc::tsip_event_info;
*tsip_event_options = *tinyWRAPc::tsip_event_options;
*tsip_event_publish = *tinyWRAPc::tsip_event_publish;
*tsip_event_register = *tinyWRAPc::tsip_event_register;
*tsip_event_subscribe = *tinyWRAPc::tsip_event_subscribe;
*tsip_event_dialog = *tinyWRAPc::tsip_event_dialog;
*tsip_event_code_dialog_transport_error = *tinyWRAPc::tsip_event_code_dialog_transport_error;
*tsip_event_code_dialog_global_error = *tinyWRAPc::tsip_event_code_dialog_global_error;
*tsip_event_code_dialog_message_error = *tinyWRAPc::tsip_event_code_dialog_message_error;
*tsip_event_code_dialog_request_incoming = *tinyWRAPc::tsip_event_code_dialog_request_incoming;
*tsip_event_code_dialog_request_outgoing = *tinyWRAPc::tsip_event_code_dialog_request_outgoing;
*tsip_event_code_dialog_request_cancelled = *tinyWRAPc::tsip_event_code_dialog_request_cancelled;
*tsip_event_code_dialog_request_sent = *tinyWRAPc::tsip_event_code_dialog_request_sent;
*tsip_event_code_dialog_request_prechecking = *tinyWRAPc::tsip_event_code_dialog_request_prechecking;
*tsip_event_code_dialog_connecting = *tinyWRAPc::tsip_event_code_dialog_connecting;
*tsip_event_code_dialog_connected = *tinyWRAPc::tsip_event_code_dialog_connected;
*tsip_event_code_dialog_terminating = *tinyWRAPc::tsip_event_code_dialog_terminating;
*tsip_event_code_dialog_terminated = *tinyWRAPc::tsip_event_code_dialog_terminated;
*tsip_event_code_stack_starting = *tinyWRAPc::tsip_event_code_stack_starting;
*tsip_event_code_stack_started = *tinyWRAPc::tsip_event_code_stack_started;
*tsip_event_code_stack_stopping = *tinyWRAPc::tsip_event_code_stack_stopping;
*tsip_event_code_stack_stopped = *tinyWRAPc::tsip_event_code_stack_stopped;
*tsip_event_code_stack_failed_to_start = *tinyWRAPc::tsip_event_code_stack_failed_to_start;
*tsip_event_code_stack_failed_to_stop = *tinyWRAPc::tsip_event_code_stack_failed_to_stop;
*tsip_event_code_stack_disconnected = *tinyWRAPc::tsip_event_code_stack_disconnected;
*tsip_i_newreg = *tinyWRAPc::tsip_i_newreg;
*tsip_i_register = *tinyWRAPc::tsip_i_register;
*tsip_ao_register = *tinyWRAPc::tsip_ao_register;
*tsip_i_unregister = *tinyWRAPc::tsip_i_unregister;
*tsip_ao_unregister = *tinyWRAPc::tsip_ao_unregister;
*tsip_i_subscribe = *tinyWRAPc::tsip_i_subscribe;
*tsip_ao_subscribe = *tinyWRAPc::tsip_ao_subscribe;
*tsip_i_unsubscribe = *tinyWRAPc::tsip_i_unsubscribe;
*tsip_ao_unsubscribe = *tinyWRAPc::tsip_ao_unsubscribe;
*tsip_i_notify = *tinyWRAPc::tsip_i_notify;
*tsip_ao_notify = *tinyWRAPc::tsip_ao_notify;
*tsip_i_publish = *tinyWRAPc::tsip_i_publish;
*tsip_ao_publish = *tinyWRAPc::tsip_ao_publish;
*tsip_i_unpublish = *tinyWRAPc::tsip_i_unpublish;
*tsip_ao_unpublish = *tinyWRAPc::tsip_ao_unpublish;
*tsip_i_message = *tinyWRAPc::tsip_i_message;
*tsip_ao_message = *tinyWRAPc::tsip_ao_message;
*tsip_i_info = *tinyWRAPc::tsip_i_info;
*tsip_ao_info = *tinyWRAPc::tsip_ao_info;
*tsip_i_options = *tinyWRAPc::tsip_i_options;
*tsip_ao_options = *tinyWRAPc::tsip_ao_options;
*tsip_i_newcall = *tinyWRAPc::tsip_i_newcall;
*tsip_i_prechecking = *tinyWRAPc::tsip_i_prechecking;
*tsip_i_request = *tinyWRAPc::tsip_i_request;
*tsip_ao_request = *tinyWRAPc::tsip_ao_request;
*tsip_o_ect_trying = *tinyWRAPc::tsip_o_ect_trying;
*tsip_o_ect_accepted = *tinyWRAPc::tsip_o_ect_accepted;
*tsip_o_ect_completed = *tinyWRAPc::tsip_o_ect_completed;
*tsip_o_ect_failed = *tinyWRAPc::tsip_o_ect_failed;
*tsip_o_ect_notify = *tinyWRAPc::tsip_o_ect_notify;
*tsip_i_ect_requested = *tinyWRAPc::tsip_i_ect_requested;
*tsip_i_ect_newcall = *tinyWRAPc::tsip_i_ect_newcall;
*tsip_i_ect_completed = *tinyWRAPc::tsip_i_ect_completed;
*tsip_i_ect_failed = *tinyWRAPc::tsip_i_ect_failed;
*tsip_i_ect_notify = *tinyWRAPc::tsip_i_ect_notify;
*tsip_m_early_media = *tinyWRAPc::tsip_m_early_media;
*tsip_m_updating = *tinyWRAPc::tsip_m_updating;
*tsip_m_updated = *tinyWRAPc::tsip_m_updated;
*tsip_m_local_hold_ok = *tinyWRAPc::tsip_m_local_hold_ok;
*tsip_m_local_hold_nok = *tinyWRAPc::tsip_m_local_hold_nok;
*tsip_m_local_resume_ok = *tinyWRAPc::tsip_m_local_resume_ok;
*tsip_m_local_resume_nok = *tinyWRAPc::tsip_m_local_resume_nok;
*tsip_m_remote_hold = *tinyWRAPc::tsip_m_remote_hold;
*tsip_m_remote_resume = *tinyWRAPc::tsip_m_remote_resume;
*tmedia_qos_stype_none = *tinyWRAPc::tmedia_qos_stype_none;
*tmedia_qos_stype_segmented = *tinyWRAPc::tmedia_qos_stype_segmented;
*tmedia_qos_stype_e2e = *tinyWRAPc::tmedia_qos_stype_e2e;
*tmedia_qos_strength_none = *tinyWRAPc::tmedia_qos_strength_none;
*tmedia_qos_strength_failure = *tinyWRAPc::tmedia_qos_strength_failure;
*tmedia_qos_strength_unknown = *tinyWRAPc::tmedia_qos_strength_unknown;
*tmedia_qos_strength_optional = *tinyWRAPc::tmedia_qos_strength_optional;
*tmedia_qos_strength_mandatory = *tinyWRAPc::tmedia_qos_strength_mandatory;
*tmedia_chroma_none = *tinyWRAPc::tmedia_chroma_none;
*tmedia_chroma_rgb24 = *tinyWRAPc::tmedia_chroma_rgb24;
*tmedia_chroma_bgr24 = *tinyWRAPc::tmedia_chroma_bgr24;
*tmedia_chroma_rgb32 = *tinyWRAPc::tmedia_chroma_rgb32;
*tmedia_chroma_rgb565le = *tinyWRAPc::tmedia_chroma_rgb565le;
*tmedia_chroma_rgb565be = *tinyWRAPc::tmedia_chroma_rgb565be;
*tmedia_chroma_nv12 = *tinyWRAPc::tmedia_chroma_nv12;
*tmedia_chroma_nv21 = *tinyWRAPc::tmedia_chroma_nv21;
*tmedia_chroma_yuv422p = *tinyWRAPc::tmedia_chroma_yuv422p;
*tmedia_chroma_uyvy422 = *tinyWRAPc::tmedia_chroma_uyvy422;
*tmedia_chroma_yuv420p = *tinyWRAPc::tmedia_chroma_yuv420p;
*tmedia_chroma_mjpeg = *tinyWRAPc::tmedia_chroma_mjpeg;
*tmedia_chroma_yuyv422 = *tinyWRAPc::tmedia_chroma_yuyv422;
*tmedia_mode_none = *tinyWRAPc::tmedia_mode_none;
*tmedia_mode_optional = *tinyWRAPc::tmedia_mode_optional;
*tmedia_mode_mandatory = *tinyWRAPc::tmedia_mode_mandatory;
*tmedia_srtp_mode_none = *tinyWRAPc::tmedia_srtp_mode_none;
*tmedia_srtp_mode_optional = *tinyWRAPc::tmedia_srtp_mode_optional;
*tmedia_srtp_mode_mandatory = *tinyWRAPc::tmedia_srtp_mode_mandatory;
*tmedia_srtp_type_none = *tinyWRAPc::tmedia_srtp_type_none;
*tmedia_srtp_type_sdes = *tinyWRAPc::tmedia_srtp_type_sdes;
*tmedia_srtp_type_dtls = *tinyWRAPc::tmedia_srtp_type_dtls;
*tmedia_srtp_type_sdes_dtls = *tinyWRAPc::tmedia_srtp_type_sdes_dtls;
*tmedia_t140_data_type_utf8 = *tinyWRAPc::tmedia_t140_data_type_utf8;
*tmedia_t140_data_type_zero_width_no_break_space = *tinyWRAPc::tmedia_t140_data_type_zero_width_no_break_space;
*tmedia_t140_data_type_backspace = *tinyWRAPc::tmedia_t140_data_type_backspace;
*tmedia_t140_data_type_esc = *tinyWRAPc::tmedia_t140_data_type_esc;
*tmedia_t140_data_type_cr = *tinyWRAPc::tmedia_t140_data_type_cr;
*tmedia_t140_data_type_lf = *tinyWRAPc::tmedia_t140_data_type_lf;
*tmedia_t140_data_type_cr_lf = *tinyWRAPc::tmedia_t140_data_type_cr_lf;
*tmedia_t140_data_type_interrupt2 = *tinyWRAPc::tmedia_t140_data_type_interrupt2;
*tmedia_t140_data_type_bell = *tinyWRAPc::tmedia_t140_data_type_bell;
*tmedia_t140_data_type_sos = *tinyWRAPc::tmedia_t140_data_type_sos;
*tmedia_t140_data_type_string_term = *tinyWRAPc::tmedia_t140_data_type_string_term;
*tmedia_t140_data_type_graphic_start = *tinyWRAPc::tmedia_t140_data_type_graphic_start;
*tmedia_t140_data_type_graphic_end = *tinyWRAPc::tmedia_t140_data_type_graphic_end;
*tmedia_t140_data_type_loss_char_char = *tinyWRAPc::tmedia_t140_data_type_loss_char_char;
*tmedia_t140_data_type_loss_utf8 = *tinyWRAPc::tmedia_t140_data_type_loss_utf8;
*tmedia_profile_default = *tinyWRAPc::tmedia_profile_default;
*tmedia_profile_rtcweb = *tinyWRAPc::tmedia_profile_rtcweb;
*tmedia_bl_low = *tinyWRAPc::tmedia_bl_low;
*tmedia_bl_medium = *tinyWRAPc::tmedia_bl_medium;
*tmedia_bl_hight = *tinyWRAPc::tmedia_bl_hight;
*tmedia_bl_unrestricted = *tinyWRAPc::tmedia_bl_unrestricted;
*tmedia_pref_video_size_sqcif = *tinyWRAPc::tmedia_pref_video_size_sqcif;
*tmedia_pref_video_size_qcif = *tinyWRAPc::tmedia_pref_video_size_qcif;
*tmedia_pref_video_size_qvga = *tinyWRAPc::tmedia_pref_video_size_qvga;
*tmedia_pref_video_size_cif = *tinyWRAPc::tmedia_pref_video_size_cif;
*tmedia_pref_video_size_hvga = *tinyWRAPc::tmedia_pref_video_size_hvga;
*tmedia_pref_video_size_vga = *tinyWRAPc::tmedia_pref_video_size_vga;
*tmedia_pref_video_size_4cif = *tinyWRAPc::tmedia_pref_video_size_4cif;
*tmedia_pref_video_size_wvga = *tinyWRAPc::tmedia_pref_video_size_wvga;
*tmedia_pref_video_size_svga = *tinyWRAPc::tmedia_pref_video_size_svga;
*tmedia_pref_video_size_480p = *tinyWRAPc::tmedia_pref_video_size_480p;
*tmedia_pref_video_size_xga = *tinyWRAPc::tmedia_pref_video_size_xga;
*tmedia_pref_video_size_720p = *tinyWRAPc::tmedia_pref_video_size_720p;
*tmedia_pref_video_size_16cif = *tinyWRAPc::tmedia_pref_video_size_16cif;
*tmedia_pref_video_size_1080p = *tinyWRAPc::tmedia_pref_video_size_1080p;
*tmedia_pref_video_size_2160p = *tinyWRAPc::tmedia_pref_video_size_2160p;
*tmedia_codec_id_none = *tinyWRAPc::tmedia_codec_id_none;
*tmedia_codec_id_amr_nb_oa = *tinyWRAPc::tmedia_codec_id_amr_nb_oa;
*tmedia_codec_id_amr_nb_be = *tinyWRAPc::tmedia_codec_id_amr_nb_be;
*tmedia_codec_id_amr_wb_oa = *tinyWRAPc::tmedia_codec_id_amr_wb_oa;
*tmedia_codec_id_amr_wb_be = *tinyWRAPc::tmedia_codec_id_amr_wb_be;
*tmedia_codec_id_gsm = *tinyWRAPc::tmedia_codec_id_gsm;
*tmedia_codec_id_pcma = *tinyWRAPc::tmedia_codec_id_pcma;
*tmedia_codec_id_pcmu = *tinyWRAPc::tmedia_codec_id_pcmu;
*tmedia_codec_id_ilbc = *tinyWRAPc::tmedia_codec_id_ilbc;
*tmedia_codec_id_speex_nb = *tinyWRAPc::tmedia_codec_id_speex_nb;
*tmedia_codec_id_speex_wb = *tinyWRAPc::tmedia_codec_id_speex_wb;
*tmedia_codec_id_speex_uwb = *tinyWRAPc::tmedia_codec_id_speex_uwb;
*tmedia_codec_id_bv16 = *tinyWRAPc::tmedia_codec_id_bv16;
*tmedia_codec_id_bv32 = *tinyWRAPc::tmedia_codec_id_bv32;
*tmedia_codec_id_opus = *tinyWRAPc::tmedia_codec_id_opus;
*tmedia_codec_id_g729ab = *tinyWRAPc::tmedia_codec_id_g729ab;
*tmedia_codec_id_g722 = *tinyWRAPc::tmedia_codec_id_g722;
*tmedia_codec_id_h261 = *tinyWRAPc::tmedia_codec_id_h261;
*tmedia_codec_id_h263 = *tinyWRAPc::tmedia_codec_id_h263;
*tmedia_codec_id_h263p = *tinyWRAPc::tmedia_codec_id_h263p;
*tmedia_codec_id_h263pp = *tinyWRAPc::tmedia_codec_id_h263pp;
*tmedia_codec_id_h264_bp = *tinyWRAPc::tmedia_codec_id_h264_bp;
*tmedia_codec_id_h264_mp = *tinyWRAPc::tmedia_codec_id_h264_mp;
*tmedia_codec_id_h264_hp = *tinyWRAPc::tmedia_codec_id_h264_hp;
*tmedia_codec_id_h264_bp10 = *tinyWRAPc::tmedia_codec_id_h264_bp10;
*tmedia_codec_id_h264_bp20 = *tinyWRAPc::tmedia_codec_id_h264_bp20;
*tmedia_codec_id_h264_bp30 = *tinyWRAPc::tmedia_codec_id_h264_bp30;
*tmedia_codec_id_h264_svc = *tinyWRAPc::tmedia_codec_id_h264_svc;
*tmedia_codec_id_theora = *tinyWRAPc::tmedia_codec_id_theora;
*tmedia_codec_id_mp4ves_es = *tinyWRAPc::tmedia_codec_id_mp4ves_es;
*tmedia_codec_id_vp8 = *tinyWRAPc::tmedia_codec_id_vp8;
*tmedia_codec_id_t140 = *tinyWRAPc::tmedia_codec_id_t140;
*tmedia_codec_id_red = *tinyWRAPc::tmedia_codec_id_red;
*tdav_codec_id_none = *tinyWRAPc::tdav_codec_id_none;
*tdav_codec_id_amr_nb_oa = *tinyWRAPc::tdav_codec_id_amr_nb_oa;
*tdav_codec_id_amr_nb_be = *tinyWRAPc::tdav_codec_id_amr_nb_be;
*tdav_codec_id_amr_wb_oa = *tinyWRAPc::tdav_codec_id_amr_wb_oa;
*tdav_codec_id_amr_wb_be = *tinyWRAPc::tdav_codec_id_amr_wb_be;
*tdav_codec_id_gsm = *tinyWRAPc::tdav_codec_id_gsm;
*tdav_codec_id_pcma = *tinyWRAPc::tdav_codec_id_pcma;
*tdav_codec_id_pcmu = *tinyWRAPc::tdav_codec_id_pcmu;
*tdav_codec_id_ilbc = *tinyWRAPc::tdav_codec_id_ilbc;
*tdav_codec_id_speex_nb = *tinyWRAPc::tdav_codec_id_speex_nb;
*tdav_codec_id_speex_wb = *tinyWRAPc::tdav_codec_id_speex_wb;
*tdav_codec_id_speex_uwb = *tinyWRAPc::tdav_codec_id_speex_uwb;
*tdav_codec_id_bv16 = *tinyWRAPc::tdav_codec_id_bv16;
*tdav_codec_id_bv32 = *tinyWRAPc::tdav_codec_id_bv32;
*tdav_codec_id_opus = *tinyWRAPc::tdav_codec_id_opus;
*tdav_codec_id_g729ab = *tinyWRAPc::tdav_codec_id_g729ab;
*tdav_codec_id_g722 = *tinyWRAPc::tdav_codec_id_g722;
*tdav_codec_id_h261 = *tinyWRAPc::tdav_codec_id_h261;
*tdav_codec_id_h263 = *tinyWRAPc::tdav_codec_id_h263;
*tdav_codec_id_h263p = *tinyWRAPc::tdav_codec_id_h263p;
*tdav_codec_id_h263pp = *tinyWRAPc::tdav_codec_id_h263pp;
*tdav_codec_id_h264_bp = *tinyWRAPc::tdav_codec_id_h264_bp;
*tdav_codec_id_h264_mp = *tinyWRAPc::tdav_codec_id_h264_mp;
*tdav_codec_id_h264_hp = *tinyWRAPc::tdav_codec_id_h264_hp;
*tdav_codec_id_h264_bp10 = *tinyWRAPc::tdav_codec_id_h264_bp10;
*tdav_codec_id_h264_bp20 = *tinyWRAPc::tdav_codec_id_h264_bp20;
*tdav_codec_id_h264_bp30 = *tinyWRAPc::tdav_codec_id_h264_bp30;
*tdav_codec_id_h264_svc = *tinyWRAPc::tdav_codec_id_h264_svc;
*tdav_codec_id_theora = *tinyWRAPc::tdav_codec_id_theora;
*tdav_codec_id_mp4ves_es = *tinyWRAPc::tdav_codec_id_mp4ves_es;
*tdav_codec_id_vp8 = *tinyWRAPc::tdav_codec_id_vp8;
*tdav_codec_id_t140 = *tinyWRAPc::tdav_codec_id_t140;
*tdav_codec_id_red = *tinyWRAPc::tdav_codec_id_red;
*thttp_event_dialog_started = *tinyWRAPc::thttp_event_dialog_started;
*thttp_event_message = *tinyWRAPc::thttp_event_message;
*thttp_event_auth_failed = *tinyWRAPc::thttp_event_auth_failed;
*thttp_event_closed = *tinyWRAPc::thttp_event_closed;
*thttp_event_transport_error = *tinyWRAPc::thttp_event_transport_error;
*thttp_event_dialog_terminated = *tinyWRAPc::thttp_event_dialog_terminated;
*twrap_rpmessage_type_sms_none = *tinyWRAPc::twrap_rpmessage_type_sms_none;
*twrap_rpmessage_type_sms_submit = *tinyWRAPc::twrap_rpmessage_type_sms_submit;
*twrap_rpmessage_type_sms_deliver = *tinyWRAPc::twrap_rpmessage_type_sms_deliver;
*twrap_rpmessage_type_sms_ack = *tinyWRAPc::twrap_rpmessage_type_sms_ack;
*twrap_rpmessage_type_sms_error = *tinyWRAPc::twrap_rpmessage_type_sms_error;
*twrap_sms_type_none = *tinyWRAPc::twrap_sms_type_none;
*twrap_sms_type_rpdata = *tinyWRAPc::twrap_sms_type_rpdata;
*twrap_sms_type_smma = *tinyWRAPc::twrap_sms_type_smma;
*twrap_sms_type_ack = *tinyWRAPc::twrap_sms_type_ack;
*twrap_sms_type_error = *tinyWRAPc::twrap_sms_type_error;
*tmsrp_NONE = *tinyWRAPc::tmsrp_NONE;
*tmsrp_SEND = *tinyWRAPc::tmsrp_SEND;
*tmsrp_REPORT = *tinyWRAPc::tmsrp_REPORT;
*tmsrp_AUTH = *tinyWRAPc::tmsrp_AUTH;
*tmsrp_event_type_none = *tinyWRAPc::tmsrp_event_type_none;
*tmsrp_event_type_connected = *tinyWRAPc::tmsrp_event_type_connected;
*tmsrp_event_type_disconnected = *tinyWRAPc::tmsrp_event_type_disconnected;
*tmsrp_event_type_message = *tinyWRAPc::tmsrp_event_type_message;
1;
